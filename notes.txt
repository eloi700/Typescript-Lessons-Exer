**  Installation of Typescript (Nodejs.org - Node Package Manager)
    npm i -g typescript

**  Typescript Version (4.8.3)
    tsc -v

**  Open Terminal Window (Ctrl-`(Backtick))

**  Compile Using Typescript Compiler
    tsc index.ts

**  Configure Typescript Compiler to target a Newer JS Version
    In this, it creates a new tsconfig.json with target es2016 etc.
    tsc --init

**  in tsconfig.json - "target": "es2016" remove and press Ctrl+Space, it
    will show the other availabe valid - esVersion.

**  IMPORTANT SETTINGS TO CONFIGURE IN tsconfig.json
**  /* Modules */---Ctrl + / - Remove the // in tsconfig.json.
    Example: rootDir: "./" represents the Current Folder (./), Sub-Folder (./src) -> Parent is helloworld and Child is src

**  */EMIT*/ --/ "outDir": "./"--Specify an output folder for all
    emitted  (JS) files. Example: "outDir": "./dist"

**  "removeComments": true, - ENABLING this from EMIT will remove the
    comments from TS.

**  "noEmitOnError": true, ENABLING this will NOT GENERATE JS if there's
    ERROR in Typescript

**  DEBUGGING TYPESCRIPT IN VS CODE
**  "sourceMap": true, - ENABLING this from EMIT will specify how each line of the Typescript code MAPS to the generated JS Code. (index.js.map)
**  Insert / Click a BreakPoint in index.ts file (color red before the line number).
**  Click the Debug Panel the Right s Icon left (Ctrl+Shift+D).
**  Click under Run and Debug the CREATE A LAUNCH.JSON FILE then NODE.JS to create LAUNCH.JSON file.
**  From launch.json file, under PROGRAM, add below line:
    "preLaunchTask": "tsc: build - tsconfig.json",
    which means that VS Code will use the TS Compiler to Build the Application using this configuration file.
**  Go back to index.ts file and click the Launch Program Play shortcut above.

**  TYPESCRIPT BUILT-IN TYPES
**  any - a variable not been annotated or initialize with value. Example: let level; ---NO NO TYPE
**  arrays
**  unknown
**  never
**  arrays
**  enum
**  tuple

**  In Typescript a number can be separated by UNDERSCORE(_) to make it readable. Example: 123_456_789

**  There's no need to ANNOTATE always the variable.  The TS compiler can infer or detect the type of the variable based on a value. Example: let sales = 123_456_789 (hover in sales, it shows a number).

**  Ctrl + P - to go to Search

**  tsconfig.json - "noImplicitAny": true, compiler will complain IMPLICIT any tags otherwise if it is false, the compiler will show only a 3 dots under on it. CAUTION: comment it or use it if you know what you are doing :)

**  node is a js engine to run js application - example command to run
    node helloworld/dist/index.js

**  BUILD & RUN
**  Windows Build - Build a JS file - Ctrl+Shift+B or
**  BUILD -- tsc -p ./helloworld/tsconfig.json (TS Compiler of Project)
**  RUN -- node helloworld/dist/index.js

**  TURN ON - "noUnusedParameters": true, /* Raise an error when a function parameter isn't read. */

**  TURN ON - "noImplicitReturns": true,  /* Enable error reporting for codepaths that do not explicitly return in a function. */

**  TURN ON - // "noUnusedLocals": true,  /* Enable error reporting when local variables aren't read. -UNUSED VARIABLES*/

**  adding ? at the end of the variable makes it Optional
    example - taxYear?:number ... if((taxYear || 2022) < 2022) or
    taxYear = 2022 : number however ... if(taxYear < 2022)

** DON'T TURN ON // "strictNullChecks": true, /* When type checking, take into account 'null' and 'undefined'. */

**  NULLISH COALESCING: The ?? Operator in TypeScript
    We can use this operator to provide a fallback value for a value that might be null or undefined. ExJS: speed: speed !== null ? speed : 30

    **  TRUTHY & FALSY VALUES IN JS - when coerced to a Boolean. The ff. values are considered to be FALSY
    *   false, 0, -0, 0n, Nan, "", null, undefined

    **  PROVIDING FALLBACK VALUES with the ?? Operator
        value ?? fallBackValue;

        If LEFT operands is NULL or UNDEFINED, the ?? expression evaluates to the right operand:
        null ?? "n/a"; ----//"n/a"
        undefined ?? "n/a"; ----//"n/a"

        OTHERWISE, the ?? expression evaluated to the left operand:
        false ?? true; ---//false
        0 ?? 100; ---//0
        "" ?? "n/a"; ---//""
        NaN ?? 0; ---//Nan

    ** || the opossite of OTHERWISE above.  The fallback value for a nullable value. The expression evaluates the respective RIGHT operands. If first value is FALSY the right value will be USED.
        false || true; ---//true
        0 || 100; ---//100
        "" || "n/a"; ---//"n/a"
        NaN || 0; ---//0

**  THE NEVER TYPE - indicates the values that will never occur.
    The never type is used when you are sure that something is never going to occur. For example, you write a function which will not return to its end point or always throws an exception.
    Example:
    function throwError(errorMsg: string): never {
            throw new Error(errorMsg);
    }

    function keepProcessing(): never {
                while (true) {
            console.log('I always does something and never ends.')
        }
    }
    **  In the above example, the throwError() function throws an error and keepProcessing() function is always executing and never reaches an end point because the while loop never ends. Thus, never type is used to indicate the value that will never occur or return from a function.

**  DIFFERENCE BETWEEN NEVER AND VOID
    The void type can have undefined or null as a value where as never cannot have any value.
    Example:
    let something: void = null;
    let nothing: never = null; Error: Type 'null' is not assignable to
        type 'never'

    **  In TS, a function that does not return a value, actually returns undefined. Example:
    function sayHi(): void{
        console.log('Hi') // Hi
    }

    let speech: void = sayHi();
    console.log(speech); // undefined

    **  speech is undefined, because the sayHi function internally returns undefined even if return type is void. If you use never type, speech:never will give a compile time error, as void is not assignable to never.

**  TURN ON but FALSE- "allowUnreachableCode": false, /* Disable error reporting for unreachable code. */

**  EXERCISES ON TYPES
    1.) Define a type alias for representing users
    let users = [
        {
            name: 'John Smith',
            age: 30,
            profession: 'Software Engineer'
        },
        {
            name: 'Kate Muller',
            age: 28
        }
    ]
    **  ANSWER
    type User = {
        name:  string,
        age:   number,
        profession? :  string;
    };

    2.) Birds fly. Fish swim. A Pet can be a Bird or Fish. Use type aliases to represent these
    type Bird = {
        fly: () => void; // type of a method or a function
    };

    type Fish = {
        swim: () => void;
    }

    type Pet = Bird | Fish;

    const myBird: Bird = {
        fly: () => {
            ...
        }
    }

    3.) Define a type for representing the days of week. Valid values are “Monday”, “Tuesday”, etc.

    **  ANSWER
    type DaysOfWeek = "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"

    let myDay: DaysOfWeek = "Thursday"

    4.) Simplify the following code snippets:
    let user = getUser();
    console.log(user && user.address ? user.address.street : undefined);
    **  ANSWER
    let user = getUser();
    console.log(user?.address?.street);

    let x = foo !== null && foo !== undefined ? foo : bar();
    **  ANSWER
    let x = foo ?? bar();

    5.) What is the problem is this piece of code?
    letvalue:unknown = 'a';
    console.log(value.toUpperCase());

    **  ANSWER
    VALUE is declared as an UNKNOWN type. In order to call methods on an unknown object, we have to use TYPE NARROWING first:

    let value : unknown = 'a';
    if (typeof value === 'string')
        console.log(value.toUpperCase());

